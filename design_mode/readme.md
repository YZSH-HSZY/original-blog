# 介绍

本目录存放设计模式相关笔记

设计模式是对一系列重复发生的问题进行一个范式的处理，是用来在特定场景下解决一般设计问题的类和相互通信的对象的描述。

> 一个模式具备几个要素: 
- 模式名(pattern name)
- 问题(problem)
- 解决方案(solution)
- 效果(consequence)

> 常见设计模式分为几种大类:
- 创建型模式
- 结构型模式
- 行为型模式

## 一些常见的设计模式

1. `Abstract Factory(抽象工厂)`: 提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。
2. `Adapter(适配器)`: 将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
3. `Bridge(桥接)`: 将抽象部分与它的实现部分分离，使它们都可以独立地变化。
4. `Builder(生成器)`: 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
5. `Chain of Responsibility(责任链)`: 解除请求的发送者和接收者之间的耦合，使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。
6. `Command(命令)`: 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。
7. `Composite(组合)`: 将对象组合成树形结构以表示“部分–整体”的层次结构。Composite使得客户对单个对象和组合对象的使用具有一致性。
8. `Decorator(装饰)`: 动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator模式比生成子类方式更为灵活。
9. `Facade(外观)`: 为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
10. `Factory Method(工厂方法)`: 定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。
11. `Flyweight(享元)`: 运用共享技术有效地支持大量细粒度的对象。
12. `Interpreter(解释器)`: 给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。
13. `Iterator(迭代器)`: 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。
14. `Mediator(中介者)`: 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
15. `Memento(备忘录)`: 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。
16. `Observer(观察者)`: 定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。
17. `Prototype(原型)`: 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。
18. `Proxy(代理)`: 为其他对象提供一个代理以控制对这个对象的访问。
19. `Singleton(单件)`: 保证一个类仅有一个实例，并提供一个访问它的全局访问点。
20. `State(状态)`: 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。
21. `Strategy(策略)`: 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。
22. `Template Method(模板方法)`: 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类不改变一个算法的结构即可重定义该算法的某些特定步骤。
23. `Visitor(访问者)`: 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

## 创建型模式

## 行为型模式

行为型模式描述对象或类的模式和它们之间的通信模式。这些模式刻画了在运行时难以跟踪的复杂的控制流。它们将你的注意力从控制流转移到对象间的联系方式上来。


### Chain of Responsibility(职责链) -- 对象行为型模式

### Command(命令) -- 对象行为型模式

将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作. 又称 `动作(action)`/`事务(transaction)`

> 实现命令模式需要考虑的问题:
1. 命令对象应达到何种智能程度
    * 一个极端是它仅确定一个接收者和执行该请求的动作。
    * 另一个极端是它自己实现所有功能，根本不需要额外的接收者对象。
    * 这两个极端间的情况是命令对象有足够的信息可以动态地找到它们的接收者。
2. 是否支持撤销（undo）和重做（redo）
    * 可能需要存储额外的状态信息，包括: 接收者对象、接收者执行处理该请求的各操作、接收者执行的操作的参数、如果处理请求的操作会改变接收者对象中的某些值，那么这些值也必须先存储起来。接收者还必须提供一些操作，以使该命令可将接收者恢复到它先前的状态。
    * 支持多级的撤销和重做，就需要有一个已被执行命令的历史列表（history list）
    * 如果命令对象复用并且其状态在各次调用之间会发生变化，还需要在放入历史列表之前先拷贝下来
3. 避免撤销操作过程中的错误积累
4. 对于简易命令来说，使用C++模板来避免为每一种动作和接收者都创建一个Command子类


### Mediator(中介者) -- 对象行为型模式

用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互

> 何时使用:
- 一组对象以良好但复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。
- 一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。
- 定制一个分布在多个类中的行为，而又不想生成太多的子类。

> 使用中介者模式需要考虑的问题:
- 同事--中介者之间通信采用的方式，常见的有两种: 观察者模式或通知接口
- 系统仅用一个中介者时，忽略抽象的中介类设计以避免过度的设计封装

### Strategy(策略) -- 对象行为型模式

定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。

> 何时使用策略模式:
- 相关的类仅仅是行为有异
- 需要一个算法的不同变体
- 算法使用客户不应该知道的数据
- 类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可以使用Strategy类代替条件语句

> 使用策略模式需要考虑的问题:
- 定义Strategy和Context接口：常用的两种方法是 Context将数据传递给Strategy 或者 Context将自身作为参数传递给Strategy
- 是否采用模板参数Strategy定义Context
- Context提供默认行为